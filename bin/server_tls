#!/usr/bin/ruby
# Usage:
# ./server_tls

# Add a TLS layer to the server
require 'socket'
require 'openssl'

class FakeTCPServer
  attr_reader :server, :host, :port

  def initialize(host = "0.0.0.0", port = 4491)
    @server = Socket.new(:INET, :STREAM)
    @addr = Socket.pack_sockaddr_in(port, host)
    @server.bind(@addr)
    @host = host
    @port = port
  end

  def listen(backlog = 5)
    server.listen(backlog)
  end

  def accept
    client, addr = server.accept
    [client, addr]
  end

  def close(conn)
    conn.close
  end
end

def run
  server = FakeTCPServer.new
  server.listen
  puts "Server booted. Listening on port #{server.host}:#{server.port}"
  puts "Press Ctrl+C to exit."
  loop do
    client, addr = server.accept
    ctx = create_ssl_context
    ssl_client = OpenSSL::SSL::SSLSocket.new(client, ctx)
    ssl_client.accept
    puts "Received connection from #{addr.ip_address}:#{addr.ip_port}\r\n"
    client_msg = ssl_client.sysread(100)
    ssl_client.syswrite("HTTP/1.0 200 OK\r\n#{ssl_client.sysread(100)}\r")
    ssl_client.sysclose
  end
end

def create_ssl_context
  # Create a new context
  ctx = OpenSSL::SSL::SSLContext.new
  # ctx.cert is the certificate used by the server
  # ctx.key is the private key used by the server
  # 1024 is the number of bits in the key
  # 'CN' is the common name of the certificate
  # 'comment' is a comment that will be added to the certificate. Here, it's 'Generated by Kenn's Server...'
  ctx.cert, ctx.key = create_self_signed_cert(1024, [['CN', 'localhost']], "Generated by Kenn's Server")

  # This is the list of ciphers that the server will accept.
  # The default is 'ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP'
  # This is a good list of ciphers to use, but you can change it if you want.
  # ADH = Anonymous Diffie-Hellman
  # EXPORT56 = Export cipher with 56-bit encryption
  # RC4+RSA = RC4 with RSA encryption
  # HIGH = High encryption
  # MEDIUM = Medium encryption
  # LOW = Low encryption
  # SSLv2 = SSL version 2
  # EXP = Export cipher
  ctx.ciphers = 'ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP'

  # ctx.verify_mode is the verification mode for the server.
  # VERIFY_PEER is the default because it's the most secure.
  #    VERIFY_PEER means that the server will verify the client's certificate.
  #    VERIFY_NONE means that the server will not verify the client's certificate.
  ctx.verify_mode = OpenSSL::SSL::VERIFY_NONE

  ctx
end

# This method creates a self-signed certificate.
def create_self_signed_cert(bits, cn, comment)
  # Create a new key
  # bits is the number of bits in the key
  # e is the public exponent. 65537 is the default.
  #   65537 is the largest public exponent that can be used without
  #   requiring more than one multiplicative operation.
  # 65537 is a Fermat prime. Fermat primes are used in RSA encryption because
  #   they are easy to compute with (i.e. one multiplicative operation).
  # The more multiplicative operations that are required, the slower the
  #   encryption algorithm will be.
  # this returns a key pair
  #  keypair.public_key is the public key
  #  keypair.private_key is the private key
  rsa = OpenSSL::PKey::RSA.new(bits, 65537)

  # Create a new certificate
  # X509 is the standard format for certificates.
  cert = OpenSSL::X509::Certificate.new
  # cert.version is the version of the certificate.
  #   0 is the default.
  #   1 is the version used by SSLv2.
  #   2 is the version used by SSLv3.
  #   3 is the version used by TLSv1.
  cert.version = 3
  # cert.serial is the serial number of the certificate.
  cert.serial = 1
  # Name.new is the name of the certificate.
  #  The first argument is an array of arrays.
  #  The first element of each sub-array is the type of name.
  #  The second element of each sub-array is the value of the name.
  #  ['CN', 'localhost'] is the common name of the certificate.
  name = OpenSSL::X509::Name.new(cn)
  # cert.subject is the subject of the certificate.
  cert.subject = name
  # cert.issuer is the issuer of the certificate.
  cert.issuer = name
  # cert.not_before is the date before which the certificate is not valid.
  cert.not_before = Time.now
  # cert.not_after is the date after which the certificate is not valid.
  # below is (365*24*60*60) seconds, or one year.
  cert.not_after = Time.now + (365*24*60*60)
  # cert.public_key is the public key of the certificate.
  cert.public_key = rsa.public_key

  # Create an extension factory
  # an extension factory is used to create extensions for certificates
  #  and certificate requests.
  # extensions are used to add extra information to certificates.
  # for example, the subject alternative name extension is used to
  #  specify the IP addresses and domain names that the certificate
  #  is valid for.
  ef = OpenSSL::X509::ExtensionFactory.new(nil,cert)
  # ef.issuer_certificate is the issuer certificate of the extension factory.
  #  this is the certificate that will be used to sign the certificate.
  # in this case, the certificate will be self-signed, so the issuer
  #  certificate is the same as the certificate.
  # we don't recommend self-signed certificates, but they are useful
  #  for testing such as this repo
  ef.issuer_certificate = cert
  # cert.extensions is the list of extensions for the certificate.
  #  this is an array of extensions.

  cert.extensions = [
    # basicConstraints is an extension that specifies whether the certificate
    #  is a CA certificate.
    # a CA means Certificate Authority.
    # a CA certificate is used to sign other certificates.
    # since we are creating a self-signed certificate, we don't need to
    #  specify this extension, or set it to false.
    ef.create_extension("basicConstraints","CA:FALSE"),
    # keyUsage is an extension that specifies the purpose of the certificate.
    # keyEncipherment is the purpose of the certificate, which means that
    #  the certificate can be used to encrypt data.
    ef.create_extension("keyUsage", "keyEncipherment"),
    # subjectKeyIdentifier is an extension that specifies the subject key
    #  identifier of the certificate.
    # "hash" means that the subject key identifier will be the hash of the
    #  certificate's public key.
    ef.create_extension("subjectKeyIdentifier", "hash"),
    # extendedKeyUsage is an extension that specifies the extended key usage
    #  of the certificate.
    # "serverAuth" is the extended key usage of the certificate, which means
    #  that the certificate can be used for server authentication.
    ef.create_extension("extendedKeyUsage", "serverAuth"),
    # nsComment is an extension that specifies a comment.
    # this is not a standard extension, but it is used by some browsers.
    ef.create_extension("nsComment", comment),
  ]

  # aki is the authority key identifier of the certificate.
  # this is the hash of the issuer's public key.
  # authority key identifiers are used to link certificates together.
  # this is not a standard extension, but it is used by some browsers.
  # this is not required, but it is recommended.
  aki = ef.create_extension("authorityKeyIdentifier",
                            "keyid:always,issuer:always")
  
  # add the authority key identifier to the list of extensions
  cert.add_extension(aki)

  # sign the certificate with the private key of the issuer
  # this is the private key of the certificate
  # this returns the certificate as a string
  cert.sign(rsa, OpenSSL::Digest::SHA1.new)

  # return the certificate and the private key
  return [ cert, rsa ]
end

run